Usuário:

Usuário - Prompt(Cliente)

* Envia para o seu cliente o tipo de conexão durante a chamada do cliente. (Afeta o modo como o cliente é inicializado)
** udp (Para definir o tipo de conexão UDP)
** tcp (Para definir o tipo de conexão TCP)
* Pode digitar as seguinte mensagens:
** login <nome> <crlf>
** logout <crlf>
** jogar <nome do jogador> <crlf>
** listar <crlf>
** parar <crlf> (Usado em partidas, isso implica que teremos estados e que em cada estado temos um conjuto de comandos
possíveis)
** mostre <crlf> (Usados em partidas, mostra as posições de onde estão as marcações.)
** marque <posição> <crlf> (Usado em partidas, marca na posição indicada)
** fame <crlf> (Ver o hall of fame)

Cliente:
* Deve lidar com as mensagens enviadas pelo usuário. Para isso teremos uma máquina de estados recebendo todas as
   mensagens.(O python tem uma biblioteca para isso)
* Deve lidar com mensagens enviadas pelo servidor. (Como solicitação de partida, Informação de deconexão ???)
* Deve lidar com mensagens enviadas por outros clientes.
((Um possível esquema de implementação)** Estados:
*** Inicial(Cliente <- Prompt(Usuário))
    Aceita apenas o comando de login. (As opções udf e tcp influenciam no uso de TLS nesse caso)
*** Aguardando resposta do servidor(Cliente <- Socket(Servidor))
    Recebe informação de sucesso ou fracasso do login
*** Logado(Cliente <- Prompt(Usuário))
    Aceita os comandos de logout, listar, jogar, fame.
*** Aguardando resposta do jogador(Cliente <- Socket(Servidor))
    Recebe informação de que o jogador aceitou ou não.
*** Jogando(Cliente <- Prompt(Usuário))
    Aceita os comandos parar, mostre e marque.
** Arestas:
*** Inicial -> Aguardando resposta do servidor (Quando Prompt(Usuário) envia login)
*** Inicial -> Inicial (Quando Prompt(Usuário) envia qualquer outra coisa diferente de login)
*** Aguardando resposta do servidor -> Logado (Quando Socket(Servidor) envia sucesso)
*** Aguardando resposta do servidor -> Inicial (Quando Socket(Servidor) envia qualquer outra coisa diferente de sucesso)
*** Logado -> Jogando (Não é possível essa transição pois é necessário a confirmação primeiro))
(Essas informações sugerem o uso de códigos rodando em paralelo. Os códigos são: Gerenciamento da entrada do propt,
gerenciamento da entrada de mensagens enviadas pelo socket(Servidor)(Usado para mostrar a mensagem que um cliente se
desconectou) e gerenciamento do recebimento de mensgens enviadas pelo socket(Cliente))
Cliente - Socket(Cliente)
Cliente - Socket(Servidor)
Cliente - Prompt(Usuário)
Cliente - TLS (Quando a conexão for TCP)

* Deve ser capaz de enviar mensagens para o servidor, as mensagens devem ser as mesmas mostradas acima.
((Uma possível implementação é usar sockets) Deve ser capaz de enviar mensagens para o socket. (Ler restrições do socket
do sistema operacional)
* Deve ser capaz de enviar mensagens para o cliente com quem está jogando.
* O usuário pode enviar mensagem para o cliente e receber mensagens do servidor ou de outro cliente ao mesmo tempo
* O cliente deve estar em estados de jogando ou não, logado ou não.


Servidor:
* O servidor deve ficar esperando um cliente se conectar.
** Uma conexão pode ser UDP ou TCP
* Para cada cliente conectado temos uma máquina de estados:
** Ficar esperando a mensagem enviada pelo usuário antes do usuário logar
*** Mensagens válidas são login
** Ficar esperando a mensagem enviada pelo usuário depois do usuário logar
*** Mensagens válidas são logout, listar, jogar e fame
** Ficar esperando a mensagem enviada pelo usuário quando ele estiver jogando
*** Mensagens válidas são parar, mostre e o marque

Servidor - Socket(Cliente) (Será usada para fazer a comunicação entre o cliente e o servidor)
Servidor - TLS
Servidor - Jogo da Velha